<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="RxJava," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="前言终究没有经受住RxJava的诱惑，只恨自己来的比较晚，走起~
RxJava 是什么？一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库~
Rx Java 有什么优势？
逻辑简洁
异步

RxJava 能做什么？
EventBus事件中心
与Retrofit结合进行网络处理
RxBinding ….

初始RxJava我们先来看一下这坨代码：
12345678910111">
<meta property="og:type" content="article">
<meta property="og:title" content="RxJava菜鸟驿站（一）">
<meta property="og:url" content="https://walid1992.github.io/2016/09/05/RxJava菜鸟驿站（一）/index.html">
<meta property="og:site_name" content="Walid's Blog">
<meta property="og:description" content="前言终究没有经受住RxJava的诱惑，只恨自己来的比较晚，走起~
RxJava 是什么？一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库~
Rx Java 有什么优势？
逻辑简洁
异步

RxJava 能做什么？
EventBus事件中心
与Retrofit结合进行网络处理
RxBinding ….

初始RxJava我们先来看一下这坨代码：
12345678910111">
<meta property="og:image" content="http://www.jcodecraeer.com/uploads/20151012/1444623685738597.png">
<meta property="og:image" content="http://www.jcodecraeer.com/uploads/20151012/1444623686863819.png">
<meta property="og:image" content="http://www.jcodecraeer.com/uploads/20151012/1444623688114171.png">
<meta property="og:image" content="http://www.jcodecraeer.com/uploads/20151012/1444623688713380.png">
<meta property="og:image" content="http://www.jcodecraeer.com/uploads/20151012/1444623689992140.png">
<meta property="og:image" content="http://www.jcodecraeer.com/uploads/20151012/1444623690796948.png">
<meta property="og:image" content="http://www.jcodecraeer.com/uploads/20151012/1444623691419731.png">
<meta property="og:image" content="http://www.jcodecraeer.com/uploads/20151012/1444623692100418.png">
<meta property="og:image" content="http://www.jcodecraeer.com/uploads/20151012/1444623692109042.png">
<meta property="og:updated_time" content="2016-09-05T11:49:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxJava菜鸟驿站（一）">
<meta name="twitter:description" content="前言终究没有经受住RxJava的诱惑，只恨自己来的比较晚，走起~
RxJava 是什么？一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库~
Rx Java 有什么优势？
逻辑简洁
异步

RxJava 能做什么？
EventBus事件中心
与Retrofit结合进行网络处理
RxBinding ….

初始RxJava我们先来看一下这坨代码：
12345678910111">
<meta name="twitter:image" content="http://www.jcodecraeer.com/uploads/20151012/1444623685738597.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://walid1992.github.io/2016/09/05/RxJava菜鸟驿站（一）/"/>

  <title> RxJava菜鸟驿站（一） | Walid's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?263fb3b738eec5b29ca04e1ba5548461";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Walid's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Luck oriented programming</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                RxJava菜鸟驿站（一）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-05T17:37:37+08:00" content="2016-09-05">
              2016-09-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/05/RxJava菜鸟驿站（一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/05/RxJava菜鸟驿站（一）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>终究没有经受住RxJava的诱惑，只恨自己来的比较晚，走起~</p>
<h1 id="RxJava-是什么？"><a href="#RxJava-是什么？" class="headerlink" title="RxJava 是什么？"></a>RxJava 是什么？</h1><p>一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库~</p>
<h1 id="Rx-Java-有什么优势？"><a href="#Rx-Java-有什么优势？" class="headerlink" title="Rx Java 有什么优势？"></a>Rx Java 有什么优势？</h1><ol>
<li>逻辑简洁</li>
<li>异步</li>
</ol>
<h1 id="RxJava-能做什么？"><a href="#RxJava-能做什么？" class="headerlink" title="RxJava 能做什么？"></a>RxJava 能做什么？</h1><ol>
<li>EventBus事件中心</li>
<li>与Retrofit结合进行网络处理</li>
<li>RxBinding ….</li>
</ol>
<h1 id="初始RxJava"><a href="#初始RxJava" class="headerlink" title="初始RxJava"></a>初始RxJava</h1><p>我们先来看一下这坨代码：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread() &#123;</div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">File</span> folder : folders) &#123;</div><div class="line">            <span class="keyword">File</span>[] files = folder.listFiles();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">File</span> <span class="keyword">file</span> : files) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">file</span>.getName().endsWith(<span class="string">".png"</span>)) &#123;</div><div class="line">                    <span class="keyword">final</span> Bitmap bitmap = getBitmapFromFile(<span class="keyword">file</span>);</div><div class="line">                    getActivity().runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                        @Override</div><div class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</div><div class="line">                            imageCollectorView.addImage(bitmap);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;&#125;.start();</div></pre></td></tr></table></figure>
<p>上面就是一个图片的遍历、过滤、加载过程，可是有强迫症的程序员都会很难过，因为又看到了影响心情的代码。</p>
<p>用RxJava如何实现呢？</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Observable.<span class="keyword">from</span>(folders)</div><div class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;<span class="keyword">File</span>, Observable&lt;<span class="keyword">File</span>&gt;&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> Observable&lt;<span class="keyword">File</span>&gt; <span class="keyword">call</span>(<span class="keyword">File</span> <span class="keyword">file</span>) &#123;</div><div class="line">            <span class="keyword">return</span> Observable.<span class="keyword">from</span>(<span class="keyword">file</span>.listFiles());</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .filter(<span class="keyword">new</span> Func1&lt;<span class="keyword">File</span>, <span class="keyword">Boolean</span>&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> <span class="keyword">Boolean</span> <span class="keyword">call</span>(<span class="keyword">File</span> <span class="keyword">file</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">file</span>.getName().endsWith(<span class="string">".png"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .map(<span class="keyword">new</span> Func1&lt;<span class="keyword">File</span>, Bitmap&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> Bitmap <span class="keyword">call</span>(<span class="keyword">File</span> <span class="keyword">file</span>) &#123;</div><div class="line">            <span class="keyword">return</span> getBitmapFromFile(<span class="keyword">file</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribeOn(Schedulers.io())</div><div class="line">    .observeOn(AndroidSchedulers.mainThread())</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">call</span>(Bitmap bitmap) &#123;</div><div class="line">            imageCollectorView.addImage(bitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>吾皇勿怒，臣妾知道代码并没有减少，可是臣妾说的是逻辑简单，链式结构非常清晰不是吗？</p>
<p>相信您在顿悟了5s中之后也看到了其好处~</p>
<h1 id="使用介绍与原理分析"><a href="#使用介绍与原理分析" class="headerlink" title="使用介绍与原理分析"></a>使用介绍与原理分析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1、扩展的观察者模式 RxJava 的异步实现，是通过一种扩展的观察者模式来实现的，A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。</p>
<p>2、RxJava的四个基本概念：</p>
<ol>
<li>Observable (可观察者，即被观察者)</li>
<li>Observer (观察者)</li>
<li>subscribe (订阅)</li>
<li>事件 ： onNext()、onCompleted() 和 onError()</li>
</ol>
<p><strong>事件</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">onNext</span><span class="params">()</span></span>: 普通事件，每个事件执行之后的event。</div><div class="line"></div><div class="line"><span class="function"><span class="title">onCompleted</span><span class="params">()</span></span>: 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的onNext() 发出时，需要触发 onCompleted() 方法作为标志。</div><div class="line"></div><div class="line"><span class="function"><span class="title">onError</span><span class="params">()</span></span>: 事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。</div></pre></td></tr></table></figure>
<p><strong>注意 ：</strong></p>
<p>在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</p>
<p><img src="http://www.jcodecraeer.com/uploads/20151012/1444623685738597.png" alt="RxJava观察者模式"></p>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>基于以上的概念， RxJava 的基本实现主要有三点：</p>
<p>1) 创建 Observer</p>
<p>Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Observer&lt;<span class="built_in">String</span>&gt; observer = <span class="literal">new</span> Observer&lt;<span class="built_in">String</span>&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="literal">void</span> onNext(<span class="built_in">String</span> s) &#123;</div><div class="line">        <span class="keyword">Log</span>.d(<span class="built_in">tag</span>, <span class="string">"Item: "</span> + s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="literal">void</span> onCompleted() &#123;</div><div class="line">        <span class="keyword">Log</span>.d(<span class="built_in">tag</span>, <span class="string">"Completed!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="literal">void</span> onError(Throwable e) &#123;</div><div class="line">        <span class="keyword">Log</span>.d(<span class="built_in">tag</span>, <span class="string">"Error!"</span>);</div><div class="line">    &#125;&#125;;</div></pre></td></tr></table></figure>
<p>除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Subscriber&lt;<span class="built_in">String</span>&gt; subscriber = <span class="literal">new</span> Subscriber&lt;<span class="built_in">String</span>&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="literal">void</span> onNext(<span class="built_in">String</span> s) &#123;</div><div class="line">        <span class="keyword">Log</span>.d(<span class="built_in">tag</span>, <span class="string">"Item: "</span> + s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="literal">void</span> onCompleted() &#123;</div><div class="line">        <span class="keyword">Log</span>.d(<span class="built_in">tag</span>, <span class="string">"Completed!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="literal">void</span> onError(Throwable e) &#123;</div><div class="line">        <span class="keyword">Log</span>.d(<span class="built_in">tag</span>, <span class="string">"Error!"</span>);</div><div class="line">    &#125;&#125;;</div></pre></td></tr></table></figure>
<p>不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用。所以如果你只想使用基本功能，选择 Observer 和 Subscriber 是完全一样的。它们的区别对于使用者来说主要有两点：</p>
<p>onStart(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。</p>
<p>unsubscribe(): 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用unsubscribe() 来解除引用关系，以避免内存泄露的发生。</p>
<p>2) 创建 Observable</p>
<p>Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"Hello"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"Hi"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"Aloha"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，这里传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者Subscriber 将会被调用三次 onNext() 和一次 onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。 这个例子很简单：事件的内容是字符串，而不是一些复杂的对象；事件的内容是已经定好了的，而不像有的观察者模式一样是待确定的（例如网络请求的结果在请求返回之前是未知的）；所有事件在一瞬间被全部发送出去，而不是夹杂一些确定或不确定的时间间隔或者经过某种触发器来触发的。总之，这个例子看起来毫无实用价值。但这是为了便于说明，实质上只要你想，各种各样的事件发送规则你都可以自己来写。至于具体怎么做，后面都会讲到，但现在不行。只有把基础原理先说明白了，上层的运用才能更容易说清楚。</p>
<p>create() 方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，例如： just(T…): 将传入的参数依次发送出来。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.just(<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>);</div><div class="line"><span class="regexp">//</span> 将会依次调用：</div><div class="line"><span class="regexp">//</span> onNext(<span class="string">"Hello"</span>);</div><div class="line"><span class="regexp">//</span> onNext(<span class="string">"Hi"</span>);</div><div class="line"><span class="regexp">//</span> onNext(<span class="string">"Aloha"</span>);</div><div class="line"><span class="regexp">//</span> onCompleted();</div></pre></td></tr></table></figure>
<p>from(T[]) / from(Iterable&lt;? extends T&gt;) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String[] words = &#123;<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>&#125;;</div><div class="line">Observable observable = Observable.from(words);</div><div class="line"><span class="regexp">//</span> 将会依次调用：</div><div class="line"><span class="regexp">//</span> onNext(<span class="string">"Hello"</span>);</div><div class="line"><span class="regexp">//</span> onNext(<span class="string">"Hi"</span>);</div><div class="line"><span class="regexp">//</span> onNext(<span class="string">"Aloha"</span>);</div><div class="line"><span class="regexp">//</span> onCompleted();</div></pre></td></tr></table></figure>
<p>上面 just(T…) 的例子和 from(T[]) 的例子，都和之前的 create(OnSubscribe) 的例子是等价的。</p>
<p>3) Subscribe (订阅)</p>
<p>创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">observable<span class="selector-class">.subscribe</span>(observer);</div><div class="line"><span class="comment">// 或者：</span></div><div class="line">observable<span class="selector-class">.subscribe</span>(subscriber);</div></pre></td></tr></table></figure>
<p>有人可能会注意到， subscribe() 这个方法有点怪：它看起来是『observalbe 订阅了 observer / subscriber』而不是『observer / subscriber 订阅了 observalbe』，这看起来就像『杂志订阅了读者』一样颠倒了对象关系。这让人读起来有点别扭，不过如果把 API 设计成 observer.subscribe(observable) / subscriber.subscribe(observable) ，虽然更加符合思维逻辑，但对流式 API 的设计就造成影响了，比较起来明显是得不偿失的。</p>
<p>Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）： // 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。 // 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">public</span> <span class="keyword">Subscription </span><span class="keyword">subscribe(Subscriber </span><span class="keyword">subscriber) </span>&#123;</div><div class="line">    <span class="keyword">subscriber.onStart();</span></div><div class="line">    onSubscribe.call(<span class="keyword">subscriber);</span></div><div class="line">    return <span class="keyword">subscriber;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码可以看出，订阅事件主要做如下几件事：</p>
<ol>
<li>onstart 准备操作</li>
<li>call 业务逻辑处理，而且业务逻辑处理并不是Observable创建时运行的，call()方法执行的时候开始运行的~</li>
<li>将传入的 Subscriber 作为 Subscription 返回。这是为了方便 unsubscribe().</li>
</ol>
<p>整个过程中对象间的关系如下图： <img src="http://www.jcodecraeer.com/uploads/20151012/1444623686863819.png" alt="订阅过程"></p>
<p>除了 subscribe(Observer) 和 subscribe(Subscriber) ，subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出Subscriber 。形式如下：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Action1<span class="variable">&lt;String&gt;</span> <span class="keyword">on</span>NextAction = new Action1<span class="variable">&lt;String&gt;</span>() &#123;</div><div class="line">    // <span class="keyword">on</span>Next()</div><div class="line">    @Override</div><div class="line">    public void call(String s) &#123;</div><div class="line">        Log.d(<span class="keyword">tag</span>, s);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Action1<span class="variable">&lt;Throwable&gt;</span> <span class="keyword">on</span>ErrorAction = new Action1<span class="variable">&lt;Throwable&gt;</span>() &#123;</div><div class="line">    // <span class="keyword">on</span>Error()</div><div class="line">    @Override</div><div class="line">    public void call(Throwable throwable) &#123;</div><div class="line">        // Error handling</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Action0 <span class="keyword">on</span>CompletedAction = new Action0() &#123;</div><div class="line">    // <span class="keyword">on</span>Completed()</div><div class="line">    @Override</div><div class="line">    public void call() &#123;</div><div class="line">        Log.d(<span class="keyword">tag</span>, <span class="string">"completed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 自动创建 Subscriber ，并使用 <span class="keyword">on</span>NextAction 来定义 <span class="keyword">on</span>Next()</div><div class="line">observable.subscribe(<span class="keyword">on</span>NextAction);</div><div class="line">// 自动创建 Subscriber ，并使用 <span class="keyword">on</span>NextAction 和 <span class="keyword">on</span>ErrorAction 来定义 <span class="keyword">on</span>Next() 和 <span class="keyword">on</span>Error()</div><div class="line">observable.subscribe(<span class="keyword">on</span>NextAction, <span class="keyword">on</span>ErrorAction);</div><div class="line">// 自动创建 Subscriber ，并使用 <span class="keyword">on</span>NextAction、 <span class="keyword">on</span>ErrorAction 和 <span class="keyword">on</span>CompletedAction 来定义 <span class="keyword">on</span>Next()、 <span class="keyword">on</span>Error() 和 <span class="keyword">on</span>Completed()</div><div class="line">observable.subscribe(<span class="keyword">on</span>NextAction, <span class="keyword">on</span>ErrorAction, <span class="keyword">on</span>CompletedAction);</div></pre></td></tr></table></figure>
<p>简单解释一下这段代码中出现的 Action1 和 Action0。 Action0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。这样其实也可以看做将 onCompleted() 方法作为参数传进了subscribe()，相当于其他某些语言中的『闭包』。 Action1 也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。事实上，虽然 Action0 和 Action1在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法。 注：正如前面所提到的，Observer 和 Subscriber 具有相同的角色，而且 Observer 在 subscribe() 过程中最终会被转换成 Subscriber 对象，因此，从这里开始，后面的描述我将用 Subscriber 来代替 Observer ，这样更加严谨。</p>
<p>4) 场景示例</p>
<p>下面举两个例子： 为了把原理用更清晰的方式表述出来，本文中挑选的都是功能尽可能简单的例子，以至于有些示例代码看起来会有『画蛇添足』『明明不用 RxJava 可以更简便地解决问题』的感觉。当你看到这种情况，不要觉得是因为 RxJava 太啰嗦，而是因为在过早的时候举出真实场景的例子并不利于原理的解析，因此我刻意挑选了简单的情景。</p>
<p>a. 打印字符串数组 将字符串数组 names 中的所有字符串依次打印出来：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>[] names = ...;</div><div class="line">Observable.from(names)</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;<span class="built_in">String</span>&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> void <span class="keyword">call</span>(<span class="built_in">String</span> name) &#123;</div><div class="line">            <span class="built_in">Log</span>.d(tag, name);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>b. 由 id 取得图片并显示 由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> drawableRes = ...;</div><div class="line">ImageView imageView = ...;</div><div class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</div><div class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</div><div class="line">        subscriber.onNext(drawable);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</div><div class="line">        imageView.setImageDrawable(drawable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        Toast.makeText(activity, <span class="string">"Error!"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>正如上面两个例子这样，创建出 Observable 和 Subscriber ，再用 subscribe() 将它们串起来，一次 RxJava 的基本使用就完成了。非常简单。</p>
<p>RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念： Scheduler 。</p>
<h2 id="线程控制-—-Scheduler基础"><a href="#线程控制-—-Scheduler基础" class="headerlink" title="线程控制 —- Scheduler基础"></a>线程控制 —- Scheduler基础</h2><p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。</p>
<p>1) Scheduler 基础的 API</p>
<p>在RxJava 中，Scheduler —-调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景：</p>
<ol>
<li>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</li>
<li>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</li>
<li>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</li>
<li><p>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>
<p>另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</p>
</li>
</ol>
<p>有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。</p>
<ol>
<li>subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。</li>
<li>observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。</li>
</ol>
<p>文字叙述总归难理解，上代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">Observable</span><span class="selector-class">.just</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">    <span class="selector-class">.subscribeOn</span>(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></div><div class="line">    <span class="selector-class">.observeOn</span>(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></div><div class="line">    <span class="selector-class">.subscribe</span>(new Action1&lt;Integer&gt;() &#123;</div><div class="line">        <span class="variable">@Override</span></div><div class="line">        public void call(Integer number) &#123;</div><div class="line">            Log<span class="selector-class">.d</span>(tag, <span class="string">"number:"</span> + number);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>上面这段代码中，由于 subscribeOn(Schedulers.io()) 的指定，被创建的事件的内容 1、2、3、4 将会在IO线程发出； 而由于observeOn(AndroidScheculers.mainThread()) 的指定，因此 subscriber 数字的打印将发生在主线程 。事实上，这种在subscribe() 之前写上两句 subscribeOn(Scheduler.io()) 和 observeOn(AndroidSchedulers.mainThread()) 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。</p>
<p>而前面提到的由图片 id 取得图片并显示的例子，如果也加上这两句：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> drawableRes = ...;</div><div class="line">ImageView imageView = ...;</div><div class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</div><div class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</div><div class="line">        subscriber.onNext(drawable);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">.subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></div><div class="line">.observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></div><div class="line">.subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</div><div class="line">        imageView.setImageDrawable(drawable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        Toast.makeText(activity, <span class="string">"Error!"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>那么，加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。</p>
<p>2) Scheduler 的原理基础</p>
<p>RxJava 的 Scheduler API 很方便，也很神奇（加了一句话就把线程切换了，怎么做到的？而且 subscribe() 不是最外层直接调用的方法吗，它竟然也能被指定线程？）。然而 Scheduler 的原理需要放在后面讲，因为它的原理是以下一节《变换》的原理作为基础的。</p>
<p>好吧这一节其实我屁也没说，只是为了让你安心，让你知道我不是忘了讲原理，而是把它放在了更合适的地方。</p>
<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。概念说着总是模糊难懂的，来看 API。</p>
<p>1) API</p>
<p>首先看一个 map() 的例子：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"images/logo.png"</span>) <span class="comment">// 输入类型 String</span></div><div class="line">    .map(<span class="keyword">new</span> Func1&lt;String, Bitmap&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function">Bitmap <span class="title">call</span><span class="params">(String filePath)</span> </span>&#123; <span class="comment">// 参数类型 String</span></div><div class="line">            <span class="function"><span class="keyword">return</span> <span class="title">getBitmapFromPath</span><span class="params">(filePath)</span></span>; <span class="comment">// 返回类型 Bitmap</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap bitmap)</span> </span>&#123; <span class="comment">// 参数类型 Bitmap</span></div><div class="line">            showBitmap(bitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>这里出现了一个叫做 Func1 的类。它和 Action1 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 Func1 和Action 的区别在于， Func1 包装的是有返回值的方法。另外，和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX和 ActionX 的区别在 FuncX 包装的是有返回值的方法。</p>
<p>可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。我列举几个常用的变换：</p>
<p>map(): 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。 map() 示意图： <img src="http://www.jcodecraeer.com/uploads/20151012/1444623688114171.png" alt="map 示意图"> flatMap(): 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Student[] students = ...;</div><div class="line">    Subscriber&lt;<span class="keyword">String</span>&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;<span class="keyword">String</span>&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> onNext(<span class="keyword">String</span> name) &#123;</div><div class="line">            Log.d(tag, name);</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;;</div><div class="line">    Observable.from(students)</div><div class="line">        .<span class="built_in">map</span>(<span class="keyword">new</span> Func1&lt;Student, <span class="keyword">String</span>&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            <span class="keyword">public</span> <span class="keyword">String</span> call(Student student) &#123;</div><div class="line">                <span class="built_in">return</span> student.getName();</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(subscriber);</div></pre></td></tr></table></figure>
<p>很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Student[] students = ...<span class="comment">;</span></div><div class="line"><span class="keyword">Subscriber&lt;Student&gt; </span><span class="keyword">subscriber </span>= new <span class="keyword">Subscriber&lt;Student&gt;() </span>&#123;</div><div class="line">    @Override</div><div class="line">    public void onNext(Student student) &#123;</div><div class="line">        List&lt;Course&gt; courses = student.getCourses()<span class="comment">;</span></div><div class="line">        for (int i = <span class="number">0</span><span class="comment">; i &lt; courses.size(); i++) &#123;</span></div><div class="line">            Course course = courses.get(i)<span class="comment">;</span></div><div class="line">            Log.d(tag, course.getName())<span class="comment">;</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;<span class="comment">;</span></div><div class="line">Observable.from(students)</div><div class="line">    .<span class="keyword">subscribe(subscriber);</span></div></pre></td></tr></table></figure>
<p>依然很简单。那么如果我不想在 Subscriber 中使用 for 循环，而是希望 Subscriber 中直接传入单个的 Course 对象呢（这对于代码复用很重要）？用 map() 显然是不行的，因为 map() 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？</p>
<p>这个时候，就需要用 flatMap() 了：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Student[] students = ...;</div><div class="line">Subscriber&lt;Course&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Course&gt;() &#123;</div><div class="line">    @<span class="function">Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span>(<span class="params">Course course</span>) &#123;</div><div class="line">        Log.d(tag, course.getName());</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line">Observable.<span class="keyword">from</span>(students)</div><div class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123;</div><div class="line">        @<span class="function">Override</span></div><div class="line">        <span class="keyword">public</span> Observable&lt;Course&gt; <span class="title">call</span>(<span class="params">Student student</span>) &#123;</div><div class="line">            <span class="keyword">return</span> Observable.<span class="keyword">from</span>(student.getCourses());</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribe(subscriber);</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出， flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map()不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的：</p>
<ol>
<li>使用传入的事件对象创建一个 Observable 对象；</li>
<li>并不发送这个 Observable, 而是将它激活，于是它开始发送事件；</li>
<li>每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。</li>
</ol>
<p>flatMap() 示意图：</p>
<p><img src="http://www.jcodecraeer.com/uploads/20151012/1444623688713380.png" alt="flatMap 示意图"></p>
<p>扩展：由于可以在嵌套的 Observable 中添加异步代码， flatMap() 也常用于嵌套的异步操作，例如嵌套的网络请求。示例代码（Retrofit + RxJava）：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">networkClient</span><span class="selector-class">.token</span>() <span class="comment">// 返回 Observable&lt;String&gt;，在订阅时请求 token，并在响应后发送 token</span></div><div class="line">    <span class="selector-class">.flatMap</span>(new Func1&lt;String, Observable&lt;Messages&gt;&gt;() &#123;</div><div class="line">        <span class="variable">@Override</span></div><div class="line">        public Observable&lt;Messages&gt; call(String token) &#123;</div><div class="line">            <span class="comment">// 返回 Observable&lt;Messages&gt;，在订阅时请求消息列表，并在响应后发送请求到的消息列表</span></div><div class="line">            return networkClient<span class="selector-class">.messages</span>();</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    <span class="selector-class">.subscribe</span>(new Action1&lt;Messages&gt;() &#123;</div><div class="line">        <span class="variable">@Override</span></div><div class="line">        public void call(Messages messages) &#123;</div><div class="line">            <span class="comment">// 处理显示消息列表</span></div><div class="line">            showMessages(messages);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>传统的嵌套请求需要使用嵌套的 Callback 来实现。而通过 flatMap() ，可以把嵌套的请求写在一条链中，从而保持程序逻辑的清晰。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">throttleFirst()</span>: 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器：</div><div class="line"></div><div class="line"><span class="less">RxView<span class="selector-class">.clickEvents</span>(button) <span class="comment">// RxBinding 代码，后面的文章有解释</span></span></div><div class="line">    <span class="selector-class">.throttleFirst</span>(<span class="number">500</span>, TimeUnit.MILLISECONDS) <span class="comment">// 设置防抖间隔为 500ms</span></div><div class="line">    <span class="selector-class">.subscribe</span>(subscriber);</div><div class="line"></div><div class="line">妈妈再也不怕我的用户手抖点开两个重复的界面啦。</div></pre></td></tr></table></figure>
<p>此外， RxJava 还提供很多便捷的方法来实现事件序列的变换，这里就不一一举例了。</p>
<p>2) 变换的原理：lift()</p>
<p>这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法：lift(Operator)。首先看一下 lift() 的内部实现（仅核心代码）：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span></div><div class="line"><span class="comment">// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。</span></div><div class="line"><span class="keyword">public</span> &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? <span class="keyword">extends</span> R, ? <span class="keyword">super</span> T&gt; operator) &#123;</div><div class="line">    <span class="function"><span class="keyword">return</span> Observable.<span class="title">create</span><span class="params">(<span class="keyword">new</span> OnSubscribe&lt;R&gt;()</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</div><div class="line">            Subscriber newSubscriber = operator.call(subscriber);</div><div class="line">            newSubscriber.onStart();</div><div class="line">            onSubscribe.call(newSubscriber);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码很有意思：它生成了一个新的 Observable 并返回，而且创建新 Observable 所用的参数 OnSubscribe 的回调方法 call() 中的实现竟然看起来和前面讲过的 Observable.subscribe() 一样！然而它们并不一样哟~不一样的地方关键就在于第二行onSubscribe.call(subscriber) 中的 onSubscribe 所指代的对象不同（高能预警：接下来的几句话可能会导致身体的严重不适）—-</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">subscribe</span><span class="params">()</span> 中这句话的 <span class="title">onSubscribe</span> 指的是 O<span class="title">bservable</span> 中的 <span class="title">onSubscribe</span> 对象，这个没有问题，但是 <span class="title">lift</span><span class="params">()</span> 之后的情况就复杂了点。</span></div><div class="line"></div><div class="line">当含有 <span class="title">lift</span><span class="params">()</span> 时：</div><div class="line">1.<span class="title">lift</span><span class="params">()</span> 创建了一个 O<span class="title">bservable</span> 后，加上之前的原始 O<span class="title">bservable</span>，已经有两个 O<span class="title">bservable</span> 了；</div><div class="line">2.而同样地，新 O<span class="title">bservable</span> 里的新 O<span class="title">nSubscribe</span> 加上之前的原始 O<span class="title">bservable</span> 中的原始 O<span class="title">nSubscribe</span>，也就有了两个O<span class="title">nSubscribe</span>；</div><div class="line">3.当用户调用经过 <span class="title">lift</span><span class="params">()</span> 后的 O<span class="title">bservable</span> 的 <span class="title">subscribe</span><span class="params">()</span> 的时候，使用的是 <span class="title">lift</span><span class="params">()</span> 所返回的新的 O<span class="title">bservable</span> ，于是它所触发的 <span class="title">onSubscribe</span>.<span class="title">call</span><span class="params">(subscriber)</span>，也是用的新 O<span class="title">bservable</span> 中的新 O<span class="title">nSubscribe</span>，即在 <span class="title">lift</span><span class="params">()</span> 中生成的那个 O<span class="title">nSubscribe</span>；</div><div class="line">4.而这个新 O<span class="title">nSubscribe</span> 的 <span class="title">call</span><span class="params">()</span> 方法中的 <span class="title">onSubscribe</span> ，就是指的原始 O<span class="title">bservable</span> 中的原始 O<span class="title">nSubscribe</span> ，在这个 <span class="title">call</span><span class="params">()</span>方法里，新 O<span class="title">nSubscribe</span> 利用 <span class="title">operator</span>.<span class="title">call</span><span class="params">(subscriber)</span> 生成了一个新的 S<span class="title">ubscriber</span>（O<span class="title">perator</span> 就是在这里，通过自己的<span class="title">call</span><span class="params">()</span> 方法将新 S<span class="title">ubscriber</span> 和原始 S<span class="title">ubscriber</span> 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新S<span class="title">ubscriber</span> 向原始 O<span class="title">bservable</span> 进行订阅。</div><div class="line">这样就实现了 <span class="title">lift</span><span class="params">()</span> 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。</div></pre></td></tr></table></figure>
<p>精简掉细节的话，也可以这么说：在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。</p>
<p>如果你更喜欢具象思维，可以看图：</p>
<p>lift() 原理图</p>
<p><img src="http://www.jcodecraeer.com/uploads/20151012/1444623689992140.png" alt="lift 原理图"></p>
<p>两次和多次的 lift() 同理，如下图：</p>
<p><img src="http://www.jcodecraeer.com/uploads/20151012/1444623690796948.png" alt="两次和多次的 lift"></p>
<p>举一个具体的 Operator 的实现。下面这是一个将事件中的 Integer 对象转换成 String 的例子，仅供参考：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">observable.lift(<span class="keyword">new</span> Observable.Operator&lt;String, Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> Integer&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber) &#123;</div><div class="line">        <span class="comment">// 将事件序列中的 Integer 对象转换为 String 对象</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                subscriber.onNext(<span class="string">""</span> + integer);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                subscriber.onError(e);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">讲述 lift() 的原理只是为了让你更好地了解 RxJava ，从而可以更好地使用它。然而不管你是否理解了 lift() 的原理，RxJava 都不建议开发者自定义 Operator 来直接使用 lift()，而是建议尽量使用已有的 lift() 包装方法（如map() flatMap() 等）进行组合来实现需求，因为直接使用 lift() 非常容易发生一些难以发现的错误。</div></pre></td></tr></table></figure>
<p>3) compose: 对 Observable 整体的变换</p>
<p>除了 lift() 之外， Observable 还有一个变换方法叫做 compose(Transformer)。它和 lift() 的区别在于， lift() 是针对事件项和事件序列的，而 compose() 是针对 Observable 自身进行变换。举个例子，假设在程序中有多个 Observable ，并且他们都需要应用一组相同的 lift() 变换。你可以这么写：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">observable1</div><div class="line">    <span class="selector-class">.lift1</span>()</div><div class="line">    <span class="selector-class">.lift2</span>()</div><div class="line">    <span class="selector-class">.lift3</span>()</div><div class="line">    <span class="selector-class">.lift4</span>()</div><div class="line">    <span class="selector-class">.subscribe</span>(subscriber1);</div><div class="line">observable2</div><div class="line">    <span class="selector-class">.lift1</span>()</div><div class="line">    <span class="selector-class">.lift2</span>()</div><div class="line">    <span class="selector-class">.lift3</span>()</div><div class="line">    <span class="selector-class">.lift4</span>()</div><div class="line">    <span class="selector-class">.subscribe</span>(subscriber2);</div><div class="line">observable3</div><div class="line">    <span class="selector-class">.lift1</span>()</div><div class="line">    <span class="selector-class">.lift2</span>()</div><div class="line">    <span class="selector-class">.lift3</span>()</div><div class="line">    <span class="selector-class">.lift4</span>()</div><div class="line">    <span class="selector-class">.subscribe</span>(subscriber3);</div><div class="line">observable4</div><div class="line">    <span class="selector-class">.lift1</span>()</div><div class="line">    <span class="selector-class">.lift2</span>()</div><div class="line">    <span class="selector-class">.lift3</span>()</div><div class="line">    <span class="selector-class">.lift4</span>()</div><div class="line">    <span class="selector-class">.subscribe</span>(subscriber1);</div></pre></td></tr></table></figure>
<p>你觉得这样太不软件工程了，于是你改成了这样：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private Observable liftAll(Observable observable) &#123;</div><div class="line">    return observable</div><div class="line">        .lift1()</div><div class="line">        .lift2()</div><div class="line">        .lift3()</div><div class="line">        .lift4()<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">...</div><div class="line">liftAll(observable1).subscribe(subscriber1)<span class="comment">;</span></div><div class="line">liftAll(observable2).subscribe(subscriber2)<span class="comment">;</span></div><div class="line">liftAll(observable3).subscribe(subscriber3)<span class="comment">;</span></div><div class="line">liftAll(observable4).subscribe(subscriber4)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>可读性、可维护性都提高了。可是 Observable 被一个方法包起来，这种方式对于 Observale 的灵活性似乎还是增添了那么点限制。怎么办？这个时候，就应该用 compose() 来解决了：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LiftAllTransformer</span> <span class="title">implements</span> <span class="title">Observable</span>.<span class="title">Transformer</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; &#123;</span></div><div class="line">    @<span class="type">Override</span></div><div class="line">    public <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; call(<span class="type">Observable</span>&lt;<span class="type">Integer</span>&gt; observable) &#123;</div><div class="line">        <span class="keyword">return</span> observable</div><div class="line">            .lift1()</div><div class="line">            .lift2()</div><div class="line">            .lift3()</div><div class="line">            .lift4();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="type">Transformer</span> liftAll = <span class="function"><span class="keyword">new</span> <span class="title">LiftAllTransformer</span>();</span></div><div class="line"><span class="title">observable1</span>.<span class="title">compose</span>(liftAll).<span class="title">subscribe</span>(subscriber1);</div><div class="line"><span class="title">observable2</span>.<span class="title">compose</span>(liftAll).<span class="title">subscribe</span>(subscriber2);</div><div class="line"><span class="title">observable3</span>.<span class="title">compose</span>(liftAll).<span class="title">subscribe</span>(subscriber3);</div><div class="line"><span class="title">observable4</span>.<span class="title">compose</span>(liftAll).<span class="title">subscribe</span>(subscriber4);</div></pre></td></tr></table></figure>
<p>像上面这样，使用 compose() 方法，Observable 可以利用传入的 Transformer 对象的 call 方法直接对自身进行处理，也就不必被包在方法的里面了。</p>
<p>compose() 的原理比较简单，不附图喽。</p>
<h2 id="线程控制：Scheduler高级"><a href="#线程控制：Scheduler高级" class="headerlink" title="线程控制：Scheduler高级"></a>线程控制：Scheduler高级</h2><p>除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。</p>
<p>1) Scheduler 高级的 API</p>
<p>前面讲到了，可以利用 subscribeOn() 结合 observeOn() 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了map() flatMap() 等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？</p>
<p>答案是：能。因为 observeOn() 指定的是 Subscriber 的线程，而这个 Subscriber 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）subscribe() 参数中的 Subscriber ，而是 observeOn() 执行时的当前 Observable 所对应的 Subscriber ，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。上代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable<span class="selector-class">.just</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// IO 线程，由 subscribeOn() 指定</span></div><div class="line">    <span class="selector-class">.subscribeOn</span>(Schedulers.io())</div><div class="line">    <span class="selector-class">.observeOn</span>(Schedulers.newThread())</div><div class="line">    <span class="selector-class">.map</span>(mapOperator) <span class="comment">// 新线程，由 observeOn() 指定</span></div><div class="line">    <span class="selector-class">.observeOn</span>(Schedulers.io())</div><div class="line">    <span class="selector-class">.map</span>(mapOperator2) <span class="comment">// IO 线程，由 observeOn() 指定</span></div><div class="line">    <span class="selector-class">.observeOn</span>(AndroidSchedulers.mainThread)</div><div class="line">    <span class="selector-class">.subscribe</span>(subscriber);  <span class="comment">// Android 主线程，由 observeOn() 指定</span></div></pre></td></tr></table></figure>
<p>如上，通过 observeOn() 的多次调用，程序实现了线程的多次切换。</p>
<p>不过，不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的。</p>
<p>又有好事的（其实还是当初的我）问了：如果我非要调用多次 subscribeOn() 呢？会有什么效果？</p>
<p>这个问题先放着，我们还是从 RxJava 线程控制的原理说起吧。</p>
<p>2) Scheduler 的原理（二）</p>
<p>其实， subscribeOn() 和 observeOn() 的内部实现，也是用的 lift()。具体看图（不同颜色的箭头表示不同的线程）：</p>
<p>subscribeOn() 原理图：</p>
<p><img src="http://www.jcodecraeer.com/uploads/20151012/1444623691419731.png" alt="subscribeOn 原理图"></p>
<p>observeOn() 原理图：</p>
<p><img src="http://www.jcodecraeer.com/uploads/20151012/1444623692100418.png" alt="observeOn 原理"></p>
<p>从图中可以看出，subscribeOn() 和 observeOn() 都做了线程切换的工作（图中的 “schedule…” 部位）。不同的是， subscribeOn()的线程切换发生在 OnSubscribe 中，即在它通知上一级 OnSubscribe 时，这时事件还没有开始发送，因此 subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。</p>
<p>最后，我用一张图来解释当多个 subscribeOn() 和 observeOn() 混合使用时，线程调度是怎么发生的（由于图中对象较多，相对于上面的图对结构做了一些简化调整）：</p>
<p>线程控制综合调用</p>
<p><img src="http://www.jcodecraeer.com/uploads/20151012/1444623692109042.png" alt="线程控制综合调用"></p>
<p>图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 subscribeOn() 影响，运行在红色线程；③和④处受第一个observeOn() 的影响，运行在绿色线程；⑤处受第二个 onserveOn() 影响，运行在紫色线程；而第二个 subscribeOn() ，由于在通知过程中线程就被第一个 subscribeOn() 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个subscribeOn() 的时候，只有第一个 subscribeOn() 起作用。</p>
<p>3) 延伸：doOnSubscribe()</p>
<p>然而，虽然超过一个的 subscribeOn() 对事件处理的流程没有影响，但在流程之前却是可以利用的。</p>
<p>在前面讲 Subscriber 的时候，提到过 Subscriber 的 onStart() 可以用作流程开始前的初始化。然而 onStart() 由于在subscribe() 发生时就被调用了，因此不能指定线程，而是只能执行在 subscribe() 被调用时的线程。这就导致如果 onStart() 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测subscribe() 将会在什么线程执行。</p>
<p>而与 Subscriber.onStart() 相对应的，有一个方法 Observable.doOnSubscribe() 。它和 Subscriber.onStart() 同样是在subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。</p>
<p>示例代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">Observable</span><span class="selector-class">.create</span>(onSubscribe)</div><div class="line">    <span class="selector-class">.subscribeOn</span>(Schedulers.io())</div><div class="line">    <span class="selector-class">.doOnSubscribe</span>(new Action0() &#123;</div><div class="line">        <span class="variable">@Override</span></div><div class="line">        public void call() &#123;</div><div class="line">            progressBar<span class="selector-class">.setVisibility</span>(View.VISIBLE); <span class="comment">// 需要在主线程执行</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    <span class="selector-class">.subscribeOn</span>(AndroidSchedulers.mainThread()) <span class="comment">// 指定主线程</span></div><div class="line">    <span class="selector-class">.observeOn</span>(AndroidSchedulers.mainThread())</div><div class="line">    <span class="selector-class">.subscribe</span>(subscriber);</div></pre></td></tr></table></figure>
<p>如上，在 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>此篇博文是RxJava最基本的介绍了，相信大家对RxJava有了初步的认识，接下来会对RXJava的应用场景进行分析~</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat_pay.png" alt="walid WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay_pay.jpg" alt="walid Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/RxJava/" rel="tag">#RxJava</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/05/Retrofit-2-0-迄今为止最大的更新最好的Android-HTTP客户端库/" rel="prev" title="Retrofit 2.0:迄今为止最大的更新最好的Android HTTP客户端库">
                Retrofit 2.0:迄今为止最大的更新最好的Android HTTP客户端库 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/09/05/RxJava菜鸟驿站（一）/"
     data-title="RxJava菜鸟驿站（一）"
     data-content=""
     data-url="https://walid1992.github.io/2016/09/05/RxJava菜鸟驿站（一）/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/09/05/RxJava菜鸟驿站（一）/"
           data-title="RxJava菜鸟驿站（一）" data-url="https://walid1992.github.io/2016/09/05/RxJava菜鸟驿站（一）/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://upload.jianshu.io/users/upload_avatars/2843033/7589285dd4fb?imageMogr/thumbnail/90x90/quality/100"
               alt="walid" />
          <p class="site-author-name" itemprop="name">walid</p>
          <p class="site-description motion-element" itemprop="description">Walid's Blog</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RxJava-是什么？"><span class="nav-number">2.</span> <span class="nav-text">RxJava 是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Rx-Java-有什么优势？"><span class="nav-number">3.</span> <span class="nav-text">Rx Java 有什么优势？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RxJava-能做什么？"><span class="nav-number">4.</span> <span class="nav-text">RxJava 能做什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#初始RxJava"><span class="nav-number">5.</span> <span class="nav-text">初始RxJava</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用介绍与原理分析"><span class="nav-number">6.</span> <span class="nav-text">使用介绍与原理分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-number">6.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本实现"><span class="nav-number">6.2.</span> <span class="nav-text">基本实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程控制-—-Scheduler基础"><span class="nav-number">6.3.</span> <span class="nav-text">线程控制 —- Scheduler基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变换"><span class="nav-number">6.4.</span> <span class="nav-text">变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程控制：Scheduler高级"><span class="nav-number">6.5.</span> <span class="nav-text">线程控制：Scheduler高级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结语"><span class="nav-number">7.</span> <span class="nav-text">结语</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">walid</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"walid"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

</body>
</html>
